{"version":3,"sources":["webpack:///webpack/bootstrap d0b62391a140f0b1c90c","webpack:///./lib/kleos_pad.js","webpack:///./lib/sequencer.js","webpack:///./lib/kick.js","webpack:///./lib/drum.js","webpack:///./lib/web_audio_context.js","webpack:///./lib/util.js","webpack:///./lib/snare.js","webpack:///./lib/hi_hat.js","webpack:///./lib/cymbal.js","webpack:///./lib/ride.js","webpack:///./lib/patterns.js","webpack:///./lib/api_util.js","webpack:///./lib/visualizer.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;ACtCA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,IAAG;AACH;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA,EAAC;;;;;;;ACnBD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,6BAA4B;AAC5B;AACA,yBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA,IAAG;;AAEH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,8CAA6C;AAC7C;AACA;AACA;AACA;AACA,aAAY;AACZ;;AAEA,gDAA+C;AAC/C;AACA;;AAEA,gEAA+D;AAC/D;AACA,yCAAwC;;AAExC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,2CAA0C;;AAE1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gDAA+C;;AAE/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAU,eAAe;AACzB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;;;AAIA;;;;;;;AC5NA;AACA;;AAEA,oCAAmC;AACnC;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA,oCAAmC;AACnC;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;AAIA;;;;;;;AClEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,kBAAiB,gBAAgB;AACjC;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,iEAAgE;;AAEhE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;;AAGA;;;;;;;ACrHA;AACA;AACA;AACA;AACA,mDAAkD;AAClD;AACA;AACA,OAAM;AACN;AACA;AACA,OAAM;AACN;AACA;AACA,OAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAQ;AACR;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;;;;;;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,IAAG;AACH,4CAA2C;AAC3C;AACA;AACA;AACA,aAAY;AACZ;AACA;;;;AAIA;;;;;;;ACpBA;AACA;;AAEA,oCAAmC;AACnC;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;AACA;AACA,wDAAuD;AACvD,0BAAyB;AACzB;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA,iCAAgC;AAChC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;AC9EA;AACA;;AAEA,oCAAmC;AACnC;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;AAIA;;;;;;;AClCA;AACA;;AAEA,+CAA8C;;AAE9C,qCAAoC;AACpC;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,oCAAmC;AACnC;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA,IAAG;;AAEH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;;;;;;;AC3DA;AACA;;AAEA,mCAAkC;AAClC;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;;AAEA;;;;;;;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACzEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;;;;;;;ACvBA;AACA;;AAEA,qBAAoB,8CAA8C;;AAElE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAAyC;AACzC;AACA,EAAC;;AAED;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,gCAA+B;;AAE/B;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,qFAAoF;AACpF;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,8BAA6B,EAAE,IAAI,EAAE,IAAI,EAAE;;AAE3C,2CAA0C;;AAE1C;AACA;AACA;AACA;AACA,4BAA2B,cAAc,IAAI,cAAc,IAAI,cAAc;AAC7E;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,mDAAkD;AAClD;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,0IAAyI;AACzI;AACA;;AAEA;AACA;AACA;AACA,4BAA2B,cAAc,IAAI,cAAc,IAAI,cAAc;AAC7E,QAAO;AACP;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,uCAAsC,mBAAmB,IAAI,mBAAmB,IAAI,mBAAmB;AACvG;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,sFAAqF;AACrF;AACA;AACA,wFAAuF;AACvF;AACA,uEAAsE;AACtE;AACA,+BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,iBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,iBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL,IAAG;;AAEH;AACA;;AAEA;AACA;AACA,oCAAmC,QAAQ,OAAO,QAAQ,IAAI,MAAM;AACpE;AACA;AACA;;AAEA,IAAG;;;AAGH;;AAEA;;AAEA,oBAAmB,OAAO;AAC1B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,YAAW;AACX;;AAEA;AACA;AACA;AACA;;AAEA,4BAA2B,2BAA2B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAA+C;AAC/C;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;;;;;;AAMA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,kBAAiB,2BAA2B;AAC5C;AACA;AACA;AACA,kDAAiD;;AAEjD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,0BAAyB,EAAE,IAAI,EAAE,IAAI,EAAE;;AAEvC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,mBAAkB,OAAO;AACzB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA","file":"./lib/bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap d0b62391a140f0b1c90c\n **/","const Sequencer = require('./sequencer');\nconst Visualizer = require('./visualizer');\n\ndocument.addEventListener(\"DOMContentLoaded\", () => {\n  //register general jquery listeners\n  $(\"#instructions-modal-overlay\").click(function(e) {\n    $(this).addClass(\"hidden\");\n  });\n  $(\"#directions\").click(function(e) {\n    $(\"#instructions-modal-overlay\").removeClass(\"hidden\");\n  });\n  $(\".exit\").click(function(e){\n    $(\"#instructions-modal-overlay\").removeClass(\"hidden\");\n  });\n  \n  //set up document\n  let canvas = document.getElementById(\"pad\");\n  let sequencer = new Sequencer();\n  let visualizer = new Visualizer(sequencer, canvas);\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/kleos_pad.js\n ** module id = 0\n ** module chunks = 0\n **/","const Kick = require('./kick');\nconst Snare = require('./snare');\nconst HiHat = require('./hi_hat');\nconst Ride = require('./ride');\nconst Patterns = require('./patterns');\nconst WebAudioContext = require('./web_audio_context');\nconst APIUtil = require('./api_util');\n\nconst Sequencer = function(){\n  \n  const INSTRUMENTS = {\n    \"kick\": Kick,\n    \"snare\": Snare,\n    \"hiHat\": HiHat,\n    \"ride\": Ride\n  };\n  \n  $( () => {\n    $('#play').click( (e) => {\n      e.preventDefault();\n      togglePaused.bind(this)();\n    });\n  });\n  \n  this.audioContext = WebAudioContext.getContext();\n  this.nextNoteTime = 0;\n  this.paused = true;\n  this.tempo = 100;\n  this.currentSixteenthNote = 0;\n  let schedulingRange = 1.5; //webaudio clock, in seconds\n  this.scheduledNotes = [];\n  this.lookahead = 75.0; //js clock, in milliseconds\n  if (!this.patternName){\n    this.patternName = \"goingHome\";\n  }\n  this.pattern = Patterns[this.patternName].map( (hits) => {\n    let drumObjects = hits.map( (drumName) => {\n      let DrumClass = INSTRUMENTS[drumName];\n      return new DrumClass();\n    });\n    return drumObjects;\n  });\n  \n  //initialize filters\n  this.filters = {};\n  \n  const nextNote = () => {\n    let beatLength = 60.0 / this.tempo;\n    \n    this.nextNoteTime += 0.25 * beatLength;\n    this.currentSixteenthNote += 1;\n    if (this.currentSixteenthNote == 16){\n      this.currentSixteenthNote = 0;\n    }\n  };\n  \n  const scheduleNoteEvents = ( beatNumber, time ) => {\n    if (time > this.currentTime() && !this.paused){\n      let hits = this.pattern[beatNumber];\n      let filters = [];\n      for (let key in this.filters){\n        filters.push(this.filters[key]);\n      }\n      hits.forEach( (hit) => {\n        hit.play(time, filters);\n      });\n    }\n  };\n  \n  this.scheduler = function() {\n    while (this.nextNoteTime < this.currentTime() + schedulingRange){\n      scheduleNoteEvents( this.currentSixteenthNote, this.nextNoteTime );\n      nextNote();\n    }\n  };\n  //make async calls and kick off playback\n  APIUtil.fetchImpulseResponseAudio(saveAudioAndPlay.bind(this));\n};\n\nSequencer.prototype.currentTime = function(){ //visualizer needs access to this for render logic\n   //will not yet exist at time of definition\n   if (this.audioContext){\n     return this.audioContext.currentTime;\n   }\n   return 0; //reasonable default\n};\n\nSequencer.prototype.callScheduler = function(){ //called by visualizer to link scheduling notes to requestAnimFrame\n  this.scheduler();\n};\n\nSequencer.prototype.updateFilters = function(xScaled, yScaled){ //scaled to %\n  //update the filters based on the position of a mouseclick in the visualizer\n  let previousFilters = Object.assign({}, this.filters);\n\n  updateLeftVertFilter.call(this, yScaled);\n  updateRightVertFilter.call(this, yScaled);\n  updateTopHorizFilter.call(this, xScaled);\n  updateBottomHorizFilter.call(this, xScaled);\n};\n  \nconst togglePaused = function(){\n  this.paused = !this.paused;\n  let text = this.paused ? \"PLAY\" : \"PAUSE\";\n  \n  if (this.paused){\n    this.pausedSixteenthNote = this.currentSixteenthNote;\n  }\n  else {\n    this.currentSixteenthNote = this.pausedSixteenthNote || 0;\n  }\n  \n  $(\"#play\").html(text);\n};\n\nconst saveAudioAndPlay = function(audio){\n  this.impulseResponseAudio = audio;\n  this.scheduler();\n};\n\nconst updateLeftVertFilter = function(yScaled){\n  //update bandpass\n  let freq = 50 + ((15950/100) * yScaled); //aim for freq range of 50-20000\n  \n  if (this.filters.biquad){\n    this.filters.biquad.node.frequency.value = freq;\n  }\n  else {\n    //set it up if it has not yet been added\n    let biquadNode = this.audioContext.createBiquadFilter();\n    biquadNode.type = \"bandpass\";\n    biquadNode.frequency.value = freq;\n    let filter = {\n      node: biquadNode,\n      splitAudioGraph: false //bool that determines whether filter should be on adjacent audio channel\n    };\n    this.filters.biquad = filter;\n  }\n};\n\nconst updateRightVertFilter = function(yScaled){\n  let gain = yScaled / 50;\n  if (this.filters.reverb){\n    this.filters.reverb.gain = gain;\n  }\n  else {\n    let reverbNode = this.audioContext.createConvolver();\n  \n      reverbNode.buffer = this.impulseResponseAudio;\n      let filter = {\n        node: reverbNode,\n        splitAudioGraph: true,\n        gain: gain\n      };\n      this.filters.reverb = filter;\n  }\n};\n\nconst updateBottomHorizFilter = function(xScaled){\n  //update distortion\n  if (this.filters.distortion){\n    this.filters.distortion.node.curve = generateDistortionCurve(xScaled);\n  }\n  else {\n    let distortionNode = this.audioContext.createWaveShaper();\n    distortionNode.curve = generateDistortionCurve(xScaled);\n    distortionNode.oversample = \"4x\";\n    let filter = {\n      node: distortionNode,\n      splitAudioGraph: true\n    };\n    this.filters.distortion = filter;\n  }\n};\n\nconst updateTopHorizFilter = function(xScaled){\n  let delayTime = (xScaled/200).toPrecision(1); //0-0.5 seconds delay, made discreet to avoid weird spacey sounds\n\n  if (this.filters.echo){\n    this.filters.echo.node.delayTime.value = delayTime;\n  }\n  else {\n    let echoNode = this.audioContext.createDelay();\n    echoNode.delayTime.value = delayTime;\n    let filter = {\n      node: echoNode,\n      splitAudioGraph: true\n    };\n    this.filters.echo = filter;\n  }\n};\n\nconst generateDistortionCurve = function(amount){\n  var k = typeof amount === 'number' ? amount : 50,\n  n_samples = 44100,\n  curve = new Float32Array(n_samples),\n  deg = Math.PI / 180,\n  i = 0,\n  x;\n  for (i ; i < n_samples; ++i ) {\n    x = i * 2 / n_samples - 1;\n    curve[i] = ( 3 + k ) * x * 20 * deg / ( Math.PI + k * Math.abs(x) );\n  }\n  return curve;\n};\n\nSequencer.prototype.resetFilters = function(){\n  //called in visualizer mouseup\n  if (Object.keys(this.filters).length > 0){\n    let timeout = window.setTimeout( () => {\n      for (let key in this.filters){\n        this.filters[key].node.disconnect();\n      }\n      this.filters = {};\n    }, 100);\n  }\n};\n\n\n\nmodule.exports = Sequencer;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/sequencer.js\n ** module id = 1\n ** module chunks = 0\n **/","const Drum = require('./drum');\nconst Util = require('./util');\n\nconst Kick = function (options = {}){\n  options.name = \"kick\";\n  \n  options.frequency = 150;\n  options.duration = 0.5;\n  \n  options.colors = {\n    clean: {\n      r: 0,\n      g: 0,\n      b: 255\n    },\n    saturated: {\n      r: 2,\n      g: 2,\n      b: 60\n    },\n    unsaturated: {\n      r: 111,\n      g: 111,\n      b: 219\n    }\n  };\n  \n  Drum.call(this, options);\n};\n\nUtil.inherits(Kick, Drum);\n\nKick.prototype.attack = function(startTime, filterNodes){\n  this.onTime = this.currentTime(); //called by visualizer\n  this.playing = true;\n  this.oscillator= this.generateOscillator();\n  this.envelope = this.generateEnvelope();\n  \n  this.buildAudioGraph(filterNodes, this.oscillator, this.envelope);\n  \n  let when = startTime > this.currentTime() ?\n  startTime - this.currentTime() :\n  0;\n  \n  this.oscillator.start(when);\n  \n};\n\nKick.prototype.release = function(){\n  let time = this.currentTime();\n  this.envelope.gain.exponentialRampToValueAtTime(0.01, time + this.duration);\n  \n  this.oscillator.frequency.exponentialRampToValueAtTime(0.01, time + this.duration);\n  \n  this.oscillator.stop(time + this.duration);\n  this.oscillator.onended = () => {\n    this.playing = false;\n    this.onTime = null;\n    this.envelope.disconnect();\n    this.silentEnvelope.disconnect();\n  };\n  \n};\n\n\n\nmodule.exports = Kick;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/kick.js\n ** module id = 2\n ** module chunks = 0\n **/","const WebAudioContext = require('./web_audio_context');\n\nconst Drum = function(options){\n  this.name = options.name;\n  \n  this.audioContext = WebAudioContext.getContext();\n  \n  this.duration = options.duration;\n  this.frequency = options.frequency;\n  \n  this.colors = options.colors;\n  this.pos = null;\n  this.playing = false;\n};\n\nDrum.prototype.generateEnvelope = function(gainValue = 0.5){\n  let envelope = this.audioContext.createGain();\n  envelope.gain.setValueAtTime(gainValue, this.currentTime());\n  return envelope;\n};\n\nDrum.prototype.generateBiquadFilter = function(options){\n  let filter = this.audioContext.createBiquadFilter();\n  filter.type = options.type;\n  filter.frequency.value = options.cutoffFreq;\n  return filter;\n};\n\nDrum.prototype.generateOscillator = function(frequency = this.frequency){\n  let oscillator = this.audioContext.createOscillator();\n  oscillator.frequency.value = frequency;\n  return oscillator;\n};\n\nDrum.prototype.generateNoise = function(){\n  let bufferSize = this.audioContext.sampleRate;\n  let buffer = this.audioContext.createBuffer(1, bufferSize, this.audioContext.sampleRate);\n  let output = buffer.getChannelData(0);\n  \n  for (let i = 0; i < bufferSize; i++) {\n    output[i] = Math.random() * 2 - 1;\n  }\n  \n  let noise = this.audioContext.createBufferSource();\n  noise.buffer = buffer;\n    \n  return noise;\n};\n\nDrum.prototype.buildAudioGraph = function(filters, ...synthesisNodes){\n  //separate the filters first\n  let sequentialFilterNodes = [];\n  let adjacentFilterNodes = [];\n  \n  filters.forEach( (filter) => {\n    if (filter.splitAudioGraph){\n      adjacentFilterNodes.push(filter.node);\n    }\n    else {\n      sequentialFilterNodes.push(filter.node);\n    }\n  });\n  \n  this.lastProcessedNode = null;\n  \n  //first we need a muted version of the synthesis to go to the output. If the nodes connecting to the output\n  //are disconnected between start and stop of note, the severed graph will not be able to end the note\n  \n  this.silentEnvelope = this.generateEnvelope(0);\n  this.silentEnvelope.connect(this.audioContext.destination);\n  let last = synthesisNodes.length - 1;\n  synthesisNodes[last].connect(this.silentEnvelope);\n  \n  //next, add the sequential filters\n  let graphNodes = synthesisNodes.concat(sequentialFilterNodes); //connect synthesis and sequential filter nodes\n  \n  graphNodes.forEach( (node, idx, arr) => {\n    if (idx === arr.length - 1){\n      node.connect(this.audioContext.destination);\n      this.lastProcessedNode = node;\n    }\n    else {\n      node.connect(arr[idx + 1]);\n    }\n  });\n  //split processed signal at any adjacent filter, creating multiple simultaneous signals\n  adjacentFilterNodes.forEach( (node) => {\n    this.lastProcessedNode.connect(node);\n    node.connect(this.audioContext.destination);\n  });\n};\n\nDrum.prototype.play = function(time, filterNodes){\n    this.attack(time, filterNodes);\n    this.release();\n  \n};\n\nDrum.prototype.currentTime = function(){\n  return this.audioContext.currentTime;\n};\n\nDrum.prototype.attack = function(){\n  //implemented by subclasses\n};\n\nDrum.prototype.release = function(){\n  //implemented by subclasses\n};\n\n//visual aspects\n\nDrum.prototype.setPos = function(pos){\n  this.pos = pos;\n};\n\n\nmodule.exports = Drum;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/drum.js\n ** module id = 3\n ** module chunks = 0\n **/","const WebAudioContext = (function () {\n  let context ;\n  // \n  // let hidden, visibilityChange;\n  // if (typeof document.hidden !== \"undefined\") { // Opera 12.10 and Firefox 18 and later support\n  //   hidden = \"hidden\";\n  //   visibilityChange = \"visibilitychange\";\n  // } else if (typeof document.mozHidden !== \"undefined\") {\n  //   hidden = \"mozHidden\";\n  //   visibilityChange = \"mozvisibilitychange\";\n  // } else if (typeof document.msHidden !== \"undefined\") {\n  //   hidden = \"msHidden\";\n  //   visibilityChange = \"msvisibilitychange\";\n  // } else if (typeof document.webkitHidden !== \"undefined\") {\n  //   hidden = \"webkitHidden\";\n  //   visibilityChange = \"webkitvisibilitychange\";\n  // }\n  \n  function createContext() {\n    const context = new AudioContext();\n    // window.addEventListener(visibilityChange, () =>{\n    //   if (document[hidden]){\n    //     context.close();\n    //   }\n    // });\n    return context;\n  }\n  \n  return {\n    getContext: function() {\n      if (!context) {\n        context = createContext();\n      }\n      return context;\n    }\n  };\n})();\n\nmodule.exports = WebAudioContext;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/web_audio_context.js\n ** module id = 4\n ** module chunks = 0\n **/","const Util = {\n  inherits: function(Child, Parent){\n    const Surrogate = function(){};\n    Surrogate.prototype = Parent.prototype;\n    Child.prototype = new Surrogate();\n    Child.prototype.constructor = Child;\n  },\n  randomInt: function(min, max){\n    return Math.floor(Math.random() * (max - min) + min);\n  },\n  getCursorPositionInCanvas(canvas, event){ //thanks to patriques http://stackoverflow.com/questions/55677/how-do-i-get-the-coordinates-of-a-mouse-click-on-a-canvas-element\n    var rect = canvas.getBoundingClientRect();\n    var x = event.clientX - rect.left;\n    var y = event.clientY - rect.top;\n    return {x: x, y: y};\n  }\n};\n\n\n\nmodule.exports = Util;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/util.js\n ** module id = 5\n ** module chunks = 0\n **/","const Drum = require('./drum');\nconst Util = require('./util');\n\nconst Snare = function(options = {}){\n  options.name = \"snare\";\n  \n  options.duration = 0.2;\n  options.frequency = 200;\n  \n  options.colors = {\n    clean: {\n      r: 1,\n      g: 128,\n      b: 1\n    },\n    saturated: {\n      r: 1,\n      g: 50,\n      b: 1\n    },\n    unsaturated: {\n      r: 174,\n      g: 241,\n      b: 174\n    }\n  };\n  \n  Drum.call(this, options);\n};\n\nUtil.inherits(Snare, Drum);\n\nSnare.prototype.attack = function(startTime, filterNodes) {\n  \n  this.playing = true;\n  this.onTime = this.currentTime();\n  \n  //generate ringing of snares with filtered white noise\n  this.noise = this.generateNoise();\n  let highPassFilter = this.generateBiquadFilter({\n    type:\"highpass\",\n    cutoffFreq:1000\n  });\n  this.noiseEnvelope = this.generateEnvelope();\n  this.buildAudioGraph(filterNodes, this.noise, highPassFilter, this.noiseEnvelope);\n\n  //generate hit\n  this.oscillator = this.generateOscillator();\n  this.oscillator.type = \"triangle\";\n  this.oscillatorEnvelope = this.generateEnvelope(0.7);//felt, not heard\n  this.hitDuration = 0.1; //cut off the hit early for snappiness\n  this.buildAudioGraph(filterNodes, this.oscillator, this.oscillatorEnvelope);\n  \n  let when = startTime > this.currentTime() ?\n  startTime - this.currentTime() :\n  0;\n  \n  \n  this.noise.start(when);\n  this.oscillator.start(when);\n};\n\nSnare.prototype.release = function() {\n  let time = this.currentTime(); //called by visualizer\n  this.oscillatorEnvelope.gain.exponentialRampToValueAtTime(0.01, time + this.hitDuration);\n  \n  this.noiseEnvelope.gain.exponentialRampToValueAtTime(0.01, time + this.duration);\n  this.oscillator.stop(time + this.duration);\n  this.noise.stop(time + this.duration);\n  this.oscillator.onended = () => {\n    this.playing = false;\n    this.onTime = null;\n    this.oscillatorEnvelope.disconnect();\n    this.noiseEnvelope.disconnect();\n    this.silentEnvelope.disconnect();\n  };\n};\n\nmodule.exports = Snare;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/snare.js\n ** module id = 6\n ** module chunks = 0\n **/","const Cymbal = require('./cymbal');\nconst Util = require('./util');\n\nconst HiHat = function(options = {}){\n  options.name = \"hiHat\";\n  \n  options.frequency = 50;\n  options.duration = 0.2;\n  \n  options.colors = {\n    saturated: {\n      r: 34,\n      g: 0,\n      b: 0\n    },\n    clean: {\n      r: 255,\n      g: 0,\n      b: 0\n    },\n    unsaturated: {\n      r: 188,\n      g: 74,\n      b: 74\n    }\n  };\n  \n  Cymbal.call(this, options);\n};\n\nUtil.inherits(HiHat, Cymbal);\n\n\n\nmodule.exports = HiHat;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/hi_hat.js\n ** module id = 7\n ** module chunks = 0\n **/","const Drum = require('./drum');\nconst Util = require('./util');\n\nconst RATIOS = [2, 3, 4.16, 5.43, 6.79, 8.21]; //ratios for metallic overtones\n\nconst Cymbal = function(options = {}){\n  this.playing = true;\n  //child classes determine frequency and duration\n  Drum.call(this, options);\n};\n\nUtil.inherits(Cymbal, Drum);\n\nCymbal.prototype.attack = function(startTime, filterNodes){\n  this.playing = true;\n  this.onTime = this.currentTime(); //called by visualizer\n  //begin by building the audio graph\n  let bandpass = this.generateBiquadFilter({\n    type:\"bandpass\",\n    cutoffFreq: 10000\n  });\n  \n  let highpass = this.generateBiquadFilter({\n    type:\"highpass\",\n    cutoffFreq: 7000\n  });\n  \n  this.envelope = this.generateEnvelope();\n\n  // //now generate the oscillators for various overtones of the hit\n  this.oscillators = RATIOS.map((ratio) => {\n    let oscillator = this.generateOscillator(this.frequency * ratio);\n    oscillator.type=\"square\";\n    this.buildAudioGraph(filterNodes, oscillator, bandpass, highpass, this.envelope);\n    let when = startTime > this.currentTime() ?\n    startTime - this.currentTime() :\n    0;\n    \n    oscillator.start(when);\n    return oscillator;\n  });\n};\n\nCymbal.prototype.release = function(){\n  let time = this.currentTime();\n  this.envelope.gain.exponentialRampToValueAtTime(1, time + 0.02);\n  this.envelope.gain.exponentialRampToValueAtTime(0.3, time + 0.03);\n  this.envelope.gain.exponentialRampToValueAtTime(0.01, time + this.duration);\n  this.oscillators.forEach((oscillator) => {\n    oscillator.stop(time + this.duration);\n    oscillator.onended = () => {\n      this.playing = false;\n      this.onTime = null;\n      this.envelope.disconnect();\n      this.silentEnvelope.disconnect();\n    };\n  });\n};\n\nmodule.exports = Cymbal;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/cymbal.js\n ** module id = 8\n ** module chunks = 0\n **/","const Cymbal = require('./cymbal');\nconst Util = require('./util');\n\nconst Ride = function(options = {}){\n  options.name = \"ride\";\n  \n  options.frequency = 500;\n  options.duration = 0.2;\n  \n  options.colors = {\n    clean: {\n      r: 196,\n      g: 85,\n      b: 105\n    },\n    saturated: {\n      r: 110,\n      g: 2,\n      b: 21\n    },\n    unsaturated: {\n      r: 255,\n      b: 192,\n      g: 203\n    }\n  };\n    \n  \n  Cymbal.call(this, options);\n};\n\nUtil.inherits(Ride, Cymbal);\n\nmodule.exports = Ride;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/ride.js\n ** module id = 9\n ** module chunks = 0\n **/","module.exports = {\n  goingHome: [ //array of events per 16th-note;\n    [\"kick\", \"hiHat\"], //instruments to play on first sixteenth note\n    [\"hiHat\"],\n    [\"hiHat\", \"ride\"],\n    [\"hiHat\"],\n    [\"kick\", \"snare\", \"hiHat\"],\n    [\"hiHat\"],\n    [\"hiHat\", \"ride\"],\n    [\"hiHat\"],\n    [\"kick\", \"hiHat\"],\n    [\"hiHat\"],\n    [\"hiHat\", \"ride\", \"snare\"],\n    [\"hiHat\"],\n    [\"kick\", \"snare\", \"hiHat\"],\n    [\"hiHat\"],\n    [\"hiHat\", \"ride\"],\n    [\"hiHat\"]\n  ],\n  heartless: [\n    [\"kick\", \"ride\"],\n    [\"ride\"],\n    [\"kick\", \"ride\"],\n    [\"ride\"],\n    [\"snare\", \"ride\"],\n    [\"snare\", \"ride\"],\n    [\"ride\"],\n    [\"snare\", \"ride\"],\n    [\"kick\", \"ride\"],\n    [\"ride\"],\n    [\"kick\", \"ride\"],\n    [\"ride\"],\n    [\"snare\", \"ride\"],\n    [\"ride\"],\n    [\"ride\"],\n    [\"ride\", \"snare\"]\n  ],\n  bass: [\n    [\"kick\"],\n    [\"kick\"],\n    [\"kick\"],\n    [\"kick\"],\n    [\"kick\"],\n    [\"kick\"],\n    [\"kick\"],\n    [\"kick\"],\n    [\"kick\"],\n    [\"kick\"],\n    [\"kick\"],\n    [\"kick\"],\n    [\"kick\"],\n    [\"kick\"],\n    [\"kick\"],\n    [\"kick\"]\n  ],\n  snare: [\n    [\"snare\"],\n    [\"snare\"],\n    [\"snare\"],\n    [\"snare\"],\n    [\"snare\"],\n    [\"snare\"],\n    [\"snare\"],\n    [\"snare\"],\n    [\"snare\"],\n    [\"snare\"],\n    [\"snare\"],\n    [\"snare\"],\n    [\"snare\"],\n    [\"snare\"],\n    [\"snare\"],\n    [\"snare\"]\n  ]\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/patterns.js\n ** module id = 10\n ** module chunks = 0\n **/","const WebAudioContext = require('./web_audio_context');\n\nmodule.exports = {\n  fetchImpulseResponseAudio: function(callback){\n    //asynchronously fetch and read audio file for impulse response\n    \n    let context = WebAudioContext.getContext();\n    let ajaxRequest = new XMLHttpRequest();\n    let crowdBuffer;\n    ajaxRequest.open('GET', 'https://s3.amazonaws.com/kleos-dev/JFKUnderpass.wav');\n    ajaxRequest.responseType = 'arraybuffer';\n    \n    ajaxRequest.onload = () => {\n      var audioData  = ajaxRequest.response;\n      context.decodeAudioData(audioData, (buffer) => {\n        crowdBuffer = buffer;\n        soundSource = context.createBufferSource();\n        soundSource.buffer = crowdBuffer;\n        callback(crowdBuffer);\n      });\n    };\n    ajaxRequest.send();\n  }\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/api_util.js\n ** module id = 11\n ** module chunks = 0\n **/","let Util = require('./util');\n//shim animation frame\n\nconst DRUM_STAFF = {\"kick\": 4, \"snare\": 3, \"hiHat\": 2, \"ride\": 1}; //canvas is reversed\n\nwindow.requestAnimFrame = (function(){\n  return window.requestAnimationFrame ||\n  window.webkitRequestAnimationFrame ||\n  window.mozRequestAnimationFrame ||\n  window.oRequestAnimationFrame ||\n  window.msRequestAnimationFrame ||\n  function( callback ){\n    window.setTimeout(callback, 1000/60); //fallback to setTimeout for ~16ms with 60hz framerate\n  };\n})();\n\nconst Visualizer = function(sequencer, canvas){\n  this.sequencer = sequencer;\n  \n  this.canvas = canvas;\n  //combine callbacks for custom 'drag' that does not move the object\n  this.canvas.addEventListener('mousedown', turnOnDragging.bind(this));\n  this.canvas.addEventListener('mouseup', turnOffDragging.bind(this));\n  this.canvas.addEventListener('mousemove', setDragImage.bind(this));\n  this.canvas.addEventListener('mouseout', turnOffDragging.bind(this));\n  \n  this.mouseImageArcsArgs = []; //a queue of positions to allow for a visual tail\n  \n  this.dragging = false;\n  \n  this.reverbRenders = {};\n  this.echoRenders = {};\n  this.distortionRenders = {};\n  this.waveIndex = 0;\n  this.shouldRenderWaves = false;\n  this.waveFadeCountdown = 3;\n  \n  \n  this.ctx = canvas.getContext('2d');\n  draw.call(this);\n  \n};\n\nconst draw = function(){\n  this.canvas.width = window.innerWidth * 0.85;\n  this.canvas.height = window.innerHeight * 0.85;\n  \n  let pattern = this.sequencer.pattern;\n  let patternLength = pattern.length;\n  \n  this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n  let maxRadialWidth = (((this.canvas.width - (this.canvas.width / 10) ) / patternLength) / 2);\n  let maxRadialHeight = ((this.canvas.height - (this.canvas.height / 10))/12);\n  this.radius = maxRadialWidth < maxRadialHeight ? maxRadialWidth : maxRadialHeight; //chose whichever constraint is smaller\n  this.padding = 0.4 * this.radius;\n  let verticalCenter = (this.canvas.height - ( ( (this.radius * 2) + (this.padding * 2) ) * 4) )/ 2;\n  \n  if (this.xScaled > 70 ) {\n    this.shouldRenderWaves = true;\n    this.waveFadeCountdown = 3;\n  }\n  \n  pattern.forEach( (drums, idx) => {\n    let beatNum = idx + 1;\n    \n    drums.forEach( (drum) => {\n      let x = ( (this.canvas.width - (this.padding * 2) ) / patternLength) * beatNum + this.padding - this.radius ;\n      let y = (((2 * this.radius) + this.padding) * DRUM_STAFF[drum.name] ) + verticalCenter;\n      drum.setPos([x,y]);\n      \n      this.canvas.style.background = \"black\";\n      \n      //EQ\n      \n      //determine color as function of biquadPos\n      let r = drum.colors.clean.r;\n      let g = drum.colors.clean.g;\n      let b = drum.colors.clean.b;\n      let playColor = `rgb(${r}, ${g}, ${b})`;\n      \n      let decimalLoc = this.yScaled / 100; //turn scaled y into a float btw 0 and 1\n        \n      if (this.sequencer.filters.biquad){\n        r = ( ( (drum.colors.unsaturated.r - drum.colors.saturated.r ) * decimalLoc ) + drum.colors.saturated.r );\n        g = ( ( (drum.colors.unsaturated.g - drum.colors.saturated.g ) * decimalLoc ) + drum.colors.saturated.g );\n        b = ( ( (drum.colors.unsaturated.b - drum.colors.saturated.b ) * decimalLoc ) + drum.colors.saturated.b );\n        playColor = `rgb(${Math.floor(r)}, ${Math.floor(g)}, ${Math.floor(b)})`;\n      }\n      \n      //REVERB\n      \n      //determine fade value based on reverb and time passed since play\n      \n      //first, record reverb data\n      if (drum.playing && this.sequencer.filters.reverb){\n        let startTime = drum.onTime + drum.duration;\n        let fadeDuration = (1 - decimalLoc) * 0.8; //maximum fadeout of 800ms for most reverb\n        let endTime = startTime + fadeDuration;\n        \n  \n        if (!this.reverbRenders[idx]){\n          this.reverbRenders[idx] = {};\n        }\n        this.reverbRenders[idx][drum.name] = {\n          start:startTime,\n          end: endTime,\n          r: r,\n          g: g,\n          b: b\n        };\n      }\n      \n      //next, process reverb data\n      let reverbData = this.reverbRenders[idx];\n      let currentTime = this.sequencer.currentTime();\n      let fadeColor;\n      if (reverbData && reverbData[drum.name] && currentTime <= reverbData[drum.name].end && currentTime >= reverbData[drum.name].start){  //second part saves trouble of removing data from object when expired\n        let capturedTime = this.sequencer.currentTime();\n        let fadeMultiplier = ((capturedTime - reverbData[drum.name].start) / (reverbData[drum.name].end - reverbData[drum.name].start));\n        \n        r = Math.abs(r - (Math.abs(reverbData[drum.name].r - 25) * fadeMultiplier));\n        g = Math.abs(g - (Math.abs(reverbData[drum.name].g - 25) * fadeMultiplier));\n        b = Math.abs(b - (Math.abs(reverbData[drum.name].b - 25) * fadeMultiplier));\n        fadeColor = `rgb(${Math.floor(r)}, ${Math.floor(g)}, ${Math.floor(b)})`;\n      } else{\n        fadeColor = \"rgb(25, 25, 25)\";\n      }\n      \n      //DELAY\n      \n      //determine outline based on echo\n      \n      //record first\n      if (drum.playing && this.sequencer.filters.echo){\n        let echoTime = Math.round((this.xScaled/200) * 10)/10;\n        let startTime = drum.onTime;\n        let endTime = startTime + echoTime;\n        if (!this.echoRenders[idx]){\n          this.echoRenders[idx] = {};\n        }\n        this.echoRenders[idx][drum.name] = {\n          start: startTime,\n          end: endTime,\n          r: r,\n          g: g,\n          b: b\n        };\n      }\n      \n      //process\n      \n      //render a bigger circle (just an outline) around radius of current circle\n\n      let echoData = this.echoRenders[idx];\n      \n      if (echoData && echoData[drum.name] && echoData[drum.name].start <= currentTime && echoData[drum.name].end >= currentTime){\n        let outerR = echoData[drum.name].r;\n        let outerG = echoData[drum.name].g;\n        let outerB = echoData[drum.name].b;\n        this.ctx.strokeStyle = `rgb(${Math.floor(outerR)}, ${Math.floor(outerG)}, ${Math.floor(outerB)})`;\n        let delaySegment = (echoData[drum.name].end - echoData[drum.name].start) / 3;\n        let timesExtra = 3 - ((Math.round(((echoData[drum.name].end - currentTime) / delaySegment))));\n        let radius = this.radius + (timesExtra);\n        \n        this.ctx.beginPath();\n        this.ctx.arc(\n          drum.pos[0],\n          drum.pos[1],\n          radius,\n          0,\n          2 * Math.PI,\n          false\n        );\n        this.ctx.stroke();\n      }\n      \n      //DISTORTION\n      \n      //randomly generate *spark* data using Bezier Paths\n      \n      // if (this.sequencer.filters.distortion && drum.playing && this.xScaled > 20){ //\n      //   //pick a random number, with the range decreasing as the distortion increases\n      //   //a zero selected will cause a path to be drawn\n      //   let max = Math.ceil( ((this.canvas.width - this.cursorX) / 1000 ) * 50) + 2; //targeting ~2 - 52 max\n      //   let min = 1;\n      //   let picked = Math.floor(Math.random() * (max - min) + min); //rand between 1 and max\n      //\n      //   if (picked === 1) { //more or less arbitrary, but since min will always be an option\n      //\n      //     let q1minX = drum.pos[0] + this.radius;\n      //     let q1maxX = q1minX + 5;\n      //     let q1minY = drum.pos[1] - this.radius;\n      //     let q1maxY = q1minY - 5;\n      //\n      //     let q2minX = drum.pos[0] - this.radius;\n      //     let q2maxX = q2minX - 5;\n      //     let q2minY = drum.pos[1] + this.radius;\n      //     let q2maxY = q2minY + 5;\n      //\n      //     let q3minX = drum.pos[0] - this.radius;\n      //     let q3maxX = q3minX - 5;\n      //     let q3minY = drum.pos[1] - this.radius;\n      //     let q3maxY = q3minY - 5;\n      //\n      //     let q4minX = drum.pos[0] + this.radius;\n      //     let q4maxX = q4minX + 5;\n      //     let q4minY = drum.pos[1] + this.radius;\n      //     let q4maxY = q4minY + 5;\n      //\n      //\n      //     let usableArea = {\n      //       1:{\n      //         minX: q1minX,\n      //         maxX: q1maxX,\n      //         minY: q1minY,\n      //         maxY: q1maxY\n      //       },\n      //       2: {\n      //         minX: q2minX,\n      //         maxX: q2maxX,\n      //         minY: q2minY,\n      //         maxY: q2maxY\n      //       },\n      //       3: {\n      //         minX: q3minX,\n      //         maxX: q3maxX,\n      //         minY: q3minY,\n      //         maxY: q3maxY\n      //       },\n      //       4: {\n      //         minX: q4minX,\n      //         maxX: q4maxX,\n      //         minY: q4minY,\n      //         maxY: q4maxY\n      //       }\n      //     };\n      //\n      //     generateRandomBezierPath.bind(this)(usableArea);\n      //\n      //   }\n      // }\n      //\n      //let's try to make some weird wavy thing for the distortion\n      \n      let renderRadius = drum.playing ? this.radius : this.radius * 0.85;\n      //\n      // if (this.sequencer.paused && drum.playing){\n      //   console.log(beatNum + drum.name);\n      //\n      // }\n      \n      \n      this.ctx.fillStyle = drum.playing ? playColor : fadeColor;\n      this.ctx.strokeStyle = \"black\";\n      this.ctx.beginPath();\n      this.ctx.arc(\n        drum.pos[0],\n        drum.pos[1],\n        renderRadius,\n        0,\n        2 * Math.PI,\n        false\n      );\n      this.ctx.stroke();\n      this.ctx.fill();\n    });\n    \n  });\n  \n  if (this.mouseImageArcsArgs.length > 0){\n    this.mouseImageArcsArgs.forEach( (args, idx) => {\n      \n      let alpha = 1.0 - (Math.pow(2, idx) * 0.05) ;\n      let rbValue = 128 - (Math.pow(2, idx) * 5);\n      this.ctx.fillStyle = `rgba(${rbValue}, 0, ${rbValue}, ${alpha})`;\n      this.ctx.beginPath();\n      this.ctx.arc(...args);\n      this.ctx.fill();\n      \n  });\n  \n  \n  if (this.sequencer.filters.distortion && (this.shouldRenderWaves || this.waveFadeCountdown > 0)){\n  \n    let newWave = false;\n  \n    for (let i = 0; i < 4; i++){\n      if (!this.distortionRenders[i]){\n        this.distortionRenders[i] = [];\n      }\n  \n      if (this.distortionRenders[i][this.waveIndex] &&\n        this.distortionRenders[i][this.waveIndex].startTime +\n        this.distortionRenders[i][this.waveIndex].duration <= this.sequencer.currentTime() ){\n          if (this.xScaled > 70){\n            this.waveIndex ++;\n            newWave = true;\n            \n          }\n          else {\n            this.shouldRenderWaves = false;\n            this.waveFadeCountdown--;\n            this.waveIndex++;\n            newWave = true;\n          }\n          \n        }\n  \n        let currentWave = this.distortionRenders[i][this.waveIndex];\n        let nextWave = this.distortionRenders[i][this.waveIndex + 1];\n  \n        if (!currentWave){\n          currentWave = generateWave.bind(this)(this.sequencer.currentTime());\n          renderWave.bind(this)(currentWave);\n          this.distortionRenders[i].push(currentWave);\n        }\n        else if (newWave){\n          renderWave.bind(this)(currentWave);\n        }\n        else {\n          if (!nextWave){\n            nextWave = generateWave.bind(this)(currentWave.startTime + currentWave.duration);\n            this.distortionRenders[i].push(nextWave);\n          }\n  \n          //now we have everything we need\n          let basePoints = currentWave.points;\n          let baseControlPoints = currentWave.controlPoints;\n  \n          let nextPoints = nextWave.points;\n          let nextControlPoints = nextWave.controlPoints;\n          let numSegments = 20;\n          let currentSegment = Math.ceil( ( numSegments * (this.sequencer.currentTime() - currentWave.startTime) ) / (currentWave.duration));\n          let percentDone = currentSegment / numSegments;\n          let transitionPoints = basePoints.map( (point, i) => {\n            let nextPoint = nextPoints[i];\n            let dx = (nextPoint[0] - point[0]) * (currentSegment / numSegments);\n            let dy = (nextPoint[1] - point[1]) * (currentSegment / numSegments);\n            let x = (point[0] + dx);\n            let y = (point[1] + dy);\n            return [x, y];\n  \n          });\n          let transitionControlPoints = {};\n  \n          for (let key in baseControlPoints){\n            transitionControlPoints[key] = [];\n            let pointsForIndex = baseControlPoints[key];\n            let nextPointsForIndex = nextControlPoints[key];\n  \n            for (let i = 0; i < pointsForIndex.length; i++){\n              let controlPoint = pointsForIndex[i];\n              let nextControlPoint = nextPointsForIndex[i];\n              let dx = (controlPoint[0] - nextControlPoint[0]) * (currentSegment / numSegments);\n              let dy = (controlPoint[1] - nextControlPoint[1]) * (currentSegment / numSegments);\n              let x = controlPoint[0] + dx;\n              let y = controlPoint[1] + dy;\n              transitionControlPoints[key].push([x,y]);\n            }\n          }\n          let transitionWave = Object.assign({}, currentWave);\n          transitionWave.points = transitionPoints;\n          transitionWave.controlPoints = transitionControlPoints;\n          \n          //this does wacky things\n          currentWave.points = transitionPoints;\n          \n          renderWave.bind(this)(transitionWave);\n        }\n    }\n  \n  \n  }\n  \n    \n    \n    \n    \n  }\n\n  this.sequencer.callScheduler();\n  requestAnimFrame(draw.bind(this));\n};\n  \n\nconst setDragImage = function(e){\n  e.preventDefault();\n  let coords = Util.getCursorPositionInCanvas.bind(this)(this.canvas, e);\n  this.cursorX = coords.x;\n  this.cursorY = coords.y;\n  if (this.dragging && !this.sequencer.paused){\n    this.mouseImageArcsArgs.unshift([\n      coords.x,\n      coords.y,\n      this.radius,\n      0,\n      2*Math.PI,\n      false\n    ]);\n    if (this.mouseImageArcsArgs.length >= 6){\n      this.mouseImageArcsArgs.pop();\n    }\n    this.xScaled = (coords.x * 100)/this.canvas.width;\n    this.yScaled = (coords.y * 100)/this.canvas.height;\n    this.sequencer.updateFilters(this.xScaled, this.yScaled);\n    \n  }\n  else {\n    this.mouseImageArcsArgs = [];\n    this.waveFadeCountdown = 0;\n    this.sequencer.resetFilters();\n  }\n};\n\nconst turnOffDragging = function(e){\n  this.dragging = false;\n};\n\nconst turnOnDragging = function(e){\n  this.dragging = true;\n};\n\nconst generateRandomBezierPath = function(usableStartArea){\n  \n  let quadrant = Math.floor(Math.random() * (5 - 1) + 1);\n  \n  let startX = Math.floor(Math.random() * (usableStartArea[quadrant].maxX - usableStartArea[quadrant].minX) + usableStartArea[quadrant].minX);\n  let startY = Math.floor(Math.random() * (usableStartArea[quadrant].maxY - usableStartArea[quadrant].minY) + usableStartArea[quadrant].minY);\n  \n  //5X5 range\n  \n  let newMaxX = startX + 15;\n  let newMinX = startX - 15;\n  let newMaxY = startY + 15;\n  let newMinY = startY - 15;\n  \n  let cp1x = Math.floor(Math.random() * (newMaxX - newMinX) + newMinX);\n  let cp1y = Math.floor(Math.random() * (newMaxY - newMinY) + newMinY);\n  let cp2x = Math.floor(Math.random() * (newMaxX - newMinX) + newMinX);\n  let cp2y = Math.floor(Math.random() * (newMaxY - newMinY) + newMinY);\n  let endX = Math.floor(Math.random() * (newMaxX - newMinX) + newMinX);\n  let endY = Math.floor(Math.random() * (newMaxY - newMinY) + newMinY);\n\n  this.ctx.beginPath();\n  this.ctx.moveTo(startX, startY);\n  this.ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, endX, endY);\n  this.ctx.strokeStyle = `rgba(81, 144, 200, 0.5)`;\n  this.ctx.stroke();\n  \n};\n\nconst generateWave = function(startTime){\n  \n  let wavePoints = generateWavePoints.bind(this)();\n  let controlPoints = {};\n  for (let i = 0; i < wavePoints.length - 1; i++){\n    let points = generateControlPointsForPoints.bind(this)(wavePoints[i], wavePoints[i+1]);\n    controlPoints[i] = points;\n  }\n  let duration = (this.sequencer.tempo / 4) / 60; //change over the course of a half note\n  \n  let lightBlue = {\n    r: 8,\n    g: 40,\n    b: 59\n  };\n  \n  let darkBlue = {\n    r: 4,\n    g: 20,\n    b: 40\n  };\n  \n  let r = Math.floor(darkBlue.r + ((lightBlue.r - darkBlue.r) * ((this.xScaled - 70) / 30)));\n  let g = Math.floor(darkBlue.g + ((lightBlue.g - darkBlue.g) * ((this.xScaled - 70) / 30)));\n  let b = Math.floor(darkBlue.b + ((lightBlue.b - darkBlue.b) * ((this.xScaled - 70) / 30)));\n  \n  let waveColor = `rgb(${r}, ${g}, ${b})`;\n  \n  let newWave = {\n    points: wavePoints,\n    controlPoints: controlPoints,\n    startTime: startTime,\n    duration: duration,\n    color: waveColor\n  };\n  \n  return newWave;\n};\n\nconst generateWavePoints = function(){\n  //build a wave object\n  let points = [];\n  let drumArea = this.canvas.width - ( 2 * this.padding );\n  \n  let minY = (this.canvas.height/2) - ( (this.canvas.height/2) * ((this.xScaled - 70) / 30) );\n  let maxY = (this.canvas.height/2) + ( (this.canvas.height/2) * ((this.xScaled - 70) / 30) );\n  \n  for ( let i = 0; i < 4; i++ ){\n    let minX = this.padding + ( ( drumArea / 4 ) * i );\n    let maxX = this.padding + ( ( drumArea /4 ) * ( i + 1 ) );\n    let x = Util.randomInt(minX, maxX);\n    let y = Util.randomInt(minY, maxY);\n    points.push([x,y]);\n  }\n  \n  return points;\n};\n\nconst generateControlPointsForPoints = function(startPoint, endPoint){\n  let controlPoints = [];\n  \n  let minY = (this.canvas.height/2) - ( (this.canvas.height/2) * ((this.xScaled - 70) /30) );\n  let maxY = (this.canvas.height/2) + ( (this.canvas.height/2) * ((this.xScaled - 70) /70) );\n  //we need two control points\n  while (controlPoints.length < 2) {\n    \n    let controlPoint;\n    let minX;\n    let maxX;\n    \n    if (controlPoints[0]){\n      minX = controlPoints[0][0] + 5;\n      maxX = endPoint[0] - 5;\n    }\n    else {\n      minX = startPoint[0] + 5;\n      maxX = endPoint[0] - 10;\n    }\n    \n    let x = Util.randomInt(minX, maxX);\n    let y = Util.randomInt(minY, maxY);\n    \n    controlPoints.push([x,y]);\n  }\n  return controlPoints;\n};\n\nconst renderWave = function(wave){\n  \n  this.ctx.globalCompositeOperation='destination-over';\n  wave.points.forEach( (point, idx, arr) => {\n    let nextPoint = arr[idx + 1];\n    if (nextPoint){\n      let controlPoints = wave.controlPoints[idx];\n      this.ctx.beginPath();\n      this.ctx.moveTo(point[0], point[1]);\n      this.ctx.bezierCurveTo(controlPoints[0][0], controlPoints[0][1], controlPoints[1][0], controlPoints[1][1], nextPoint[0], nextPoint[1]);\n      this.ctx.strokeStyle = wave.color;\n      this.ctx.stroke();\n    }\n  });\n};\n\nmodule.exports = Visualizer;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/visualizer.js\n ** module id = 12\n ** module chunks = 0\n **/"],"sourceRoot":""}